
Write a program to implement depth first search algorithm. 
GRAPH:- 
 
PYTHON CODE:- 
graph1 = { 
         'A': set(['B', 'C']), 
         'B': set(['A', 'D', 'E']), 
         'C': set(['A', 'F']), 
         'D': set(['B']), 
         'E': set(['B', 'F']), 
         'F': set(['C', 'E']) 
        } 
def dfs(graph, node, visited):     if node not in visited:         visited.append(node)         for n in graph[node]:             dfs(graph,n, visited)     return visited visited = dfs(graph1,'A', []) print(visited)  
 --------------------------------------------------------------------------------------------------------------------------
PYTHON CODE:- 
graph1 = { 
'A': set(['B', 'C']), 
'B': set(['A', 'D', 'E']), 
'C': set(['A', 'F']), 
'D': set(['B']), 
'E': set(['B', 'F']), 
'F': set(['C', 'E']) 
} 

def bfs(graph, start):
    visited, queue = [], deque([start])
    while queue:
        node = queue.popleft()
        if node not in visited:
            visited.append(node)
            queue.extend(graph[node] - set(visited))
    return visited

print(bfs(graph1, 'A')) 
 --------------------------------------------------------------------------------------------------------------------------
Write a program to solve tower of Hanoi problem. 
 
PYTHON CODE: def moveTower(height,fromPole, toPole, withPole):     if height >= 1: 
        moveTower(height-1,fromPole,withPole,toPole)         moveDisk(fromPole,toPole)         moveTower(height-1,withPole,toPole,fromPole) def moveDisk(fp,tp):     print("moving disk from",fp,"to",tp) moveTower(3,"A","B","C") 
 
 
PRACTICAL NO.-3 
A.	Write a program to implement alpha beta search.  
B.	Write a program for Hill climbing problem. 
 
AIM:- 
Write a program to implement alpha beta search. 
 
PYTHON CODE 
tree = [[[5, 1, 2], [8, -8, -9]], [[9, 4, 5], [-3, 4, 3]]] root = 0 
pruned = 0 
 
def children(branch, depth, alpha, beta): 
    global tree     global root     global pruned     i = 0     for child in branch:         if type(child) is list: 
            (nalpha, nbeta) = children(child, depth + 1, alpha, beta)             if depth % 2 == 1:                 beta = nalpha if nalpha < beta else beta             else: 
                alpha = nbeta if nbeta > alpha else alpha 
            branch[i] = alpha if depth % 2 == 0 else beta             i += 1         else: 
            if depth % 2 == 0 and alpha < child:                 alpha = child             if depth % 2 == 1 and beta > child: 
                beta = child             if alpha >= beta:                 pruned += 1                 break     if depth == root:         tree = alpha if root == 0 else beta     return (alpha, beta) 
 
def alphabeta(in_tree=tree, start=root, upper=-15, lower=15): 
    global tree 
    global pruned 
    global root 
 
    (alpha, beta) = children(tree, start, upper, lower) 
     
    if __name__ == "__main__": 
        print ("(alpha, beta): ", alpha, beta)         print ("Result: ", tree) 
        print ("Times pruned: ", pruned) 
 
    return (alpha, beta, tree, pruned) 
 
if __name__ == "__main__": 
    alphabeta(None) 
 -------------------------------------------------------------------------------------------------------------------------- 
Write a program for Hill climbing problem. 
DIAGRAM:- 
 
 
increment = 0.1 startingPoint = [1, 1] point1 = [1,5] point2 = [6,4] point3 = [5,2] point4 = [2,1] 
 
def distance(x1, y1, x2, y2): 
    dist = math.pow(x2-x1, 2) + math.pow(y2-y1, 2)     return dist 
 
def sumOfDistances(x1, y1, px1, py1, px2, py2, px3, py3, px4, py4): 
    d1 = distance(x1, y1, px1, py1)     d2 = distance(x1, y1, px2, py2)     d3 = distance(x1, y1, px3, py3)     d4 = distance(x1, y1, px4, py4) 
 
    return d1 + d2 + d3 + d4 
 
def newDistance(x1, y1, point1, point2, point3, point4): 
    d1 = [x1, y1]     d1temp = sumOfDistances(x1, y1, point1[0],point1[1], point2[0],point2[1],                                 point3[0],point3[1], point4[0],point4[1] )     d1.append(d1temp) 
    return d1 
 
minDistance = sumOfDistances(startingPoint[0], startingPoint[1], point1[0],point1[1], point2[0],point2[1], 
                                point3[0],point3[1], point4[0],point4[1] ) flag = True 
 
def newPoints(minimum, d1, d2, d3, d4):     if d1[2] == minimum:         return [d1[0], d1[1]]     elif d2[2] == minimum:         return [d2[0], d2[1]]     elif d3[2] == minimum:         return [d3[0], d3[1]]     elif d4[2] == minimum:         return [d4[0], d4[1]] 
 
i = 1 while flag:     d1 = newDistance(startingPoint[0]+increment, startingPoint[1], point1, point2, point3, point4)     d2 = newDistance(startingPoint[0]-increment, startingPoint[1], point1, point2, point3, point4)     d3 = newDistance(startingPoint[0], startingPoint[1]+increment, point1, point2, point3, point4)     d4 = newDistance(startingPoint[0], startingPoint[1]-increment, point1, point2, point3, point4) 
    print (i,' ', round(startingPoint[0], 2), round(startingPoint[1], 2)) 
    minimum = min(d1[2], d2[2], d3[2], d4[2])     if minimum < minDistance:         startingPoint = newPoints(minimum, d1, d2, d3, d4)         minDistance = minimum 
        #print i,' ', round(startingPoint[0], 2), round(startingPoint[1], 2)         i+=1 
    else: 
--------------------------------------------------------------------------------------------------------------------------
Write a program to implement A* algorithm. 
  
PYTHON CODE:- 
from simpleai.search import SearchProblem, astar 
 
GOAL = 'HELLO WORLD' 
class HelloProblem(SearchProblem):     def actions(self, state): 
        if len(state) < len(GOAL): 
            return list(' ABCDEFGHIJKLMNOPQRSTUVWXYZ')         else:             return [] 
 
    def result(self, state, action): 
        return state + action 
 
    def is_goal(self, state):         return state == GOAL 
 
    def heuristic(self, state): 
        # how far are we from the goal?         wrong = sum([1 if state[i] != GOAL[i] else 0                     for i in range(len(state))])         missing = len(GOAL) - len(state) 
        return wrong + missing 
 
problem = HelloProblem(initial_state='') result = astar(problem) print(result.state) print(result.path()) 
 --------------------------------------------------------------------------------------------------------------------------
-------------------------------------
Design the simulation of TIC – TAC –TOE game using min-max algorithm Diagram:- 
 
import time     
     
board = [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ']     
player = 1     
    
########win Flags##########     
Win = 1     
Draw = -1     
Running = 0     
Stop = 1     
###########################     
Game = Running     
Mark = 'X'     
    
#This Function Draws Game Board     
def DrawBoard():         print(" %c | %c | %c " % (board[1],board[2],board[3]))         print("___|___|___")     
    print(" %c | %c | %c " % (board[4],board[5],board[6]))         print("___|___|___")     
    print(" %c | %c | %c " % (board[7],board[8],board[9]))         print("   |   |   ")     
    
#This Function Checks position is empty or not     def CheckPosition(x):         if(board[x] == ' '):     
        return True         else:     
        return False     
    
#This Function Checks player has won or not     def CheckWin():         global Game     
    #Horizontal winning condition         if(board[1] == board[2] and board[2] == board[3] and board[1] != ' '):             Game = Win         elif(board[4] == board[5] and board[5] == board[6] and board[4] != ' '):             Game = Win         elif(board[7] == board[8] and board[8] == board[9] and board[7] != ' '):             Game = Win     
    #Vertical Winning Condition         elif(board[1] == board[4] and board[4] == board[7] and board[1] != ' '):             Game = Win         elif(board[2] == board[5] and board[5] == board[8] and board[2] != ' '):             Game = Win         elif(board[3] == board[6] and board[6] == board[9] and board[3] != ' '):             Game=Win     
    #Diagonal Winning Condition         elif(board[1] == board[5] and board[5] == board[9] and board[5] != ' '):             Game = Win         elif(board[3] == board[5] and board[5] == board[7] and board[5] != ' '):             Game=Win     
    #Match Tie or Draw Condition         elif(board[1]!=' ' and board[2]!=' ' and board[3]!=' ' and board[4]!=' ' and board[5]!=' ' and board[6]!=' ' and board[7]!=' ' and board[8]!=' ' and board[9]!=' '):     
        Game=Draw         else:             
        Game=Running     
     
print("Tic-Tac-Toe Game")     print("Player 1 [X] --- Player 2 [O]\n")     print()     print()     
print("Please Wait...")     time.sleep(1)     while(Game == Running):     
    os.system('cls')         DrawBoard()         if(player % 2 != 0):             print("Player 1's chance")             Mark = 'X'         else:     
        print("Player 2's chance")             Mark = 'O'         choice = int(input("Enter the position between [1-9] where you want to mark : 
"))     
    if(CheckPosition(choice)):             board[choice] = Mark     
        player+=1             CheckWin()     
     
os.system('cls')     DrawBoard()     if(Game==Draw):     
    print("Game Draw")     elif(Game==Win):         player-=1         if(player%2!=0):     
        print("Player 1 Won")         else:     
        print("Player 2 Won")     
 --------------------------------------------------------------------------------------------------------------------------
 --------------------------------------------------------------------------------------------------------------------------

Design an application to simulate number puzzle problem. 
PYHTON CODE:- 
''' 
8 puzzle problem, a smaller version of the fifteen puzzle: 
States are defined as string representations of the pieces on the puzzle. 
Actions denote what piece will be moved to the empty space. 
States must allways be inmutable. We will use strings, but internally most of the time we will convert those strings to lists, which are easier to handle. For example, the state (string): 
'1-2-3  4-5-6  7-8-e' will become (in lists): 
[['1', '2', '3'], 
 ['4', '5', '6'], 
 ['7', '8', 'e']] 
 
''' 
 
from __future__ import print_function from simpleai.search import astar, SearchProblem from simpleai.search.viewers import WebViewer 
 
GOAL = '''1-2-3 
4-5-6 
7-	8-e''' 
 
INITIAL = '''4-1-2 
7-e-3 
8-	5-6''' 
 
 
def list_to_string(list_): 
    return '\n'.join(['-'.join(row) for row in list_]) 
 
 
def string_to_list(string_):     return [row.split('-') for row in string_.split('\n')] def find_location(rows, element_to_find):     '''Find the location of a piece in the puzzle.        Returns a tuple: row, column'''     for ir, row in enumerate(rows):         for ic, element in enumerate(row):             if element == element_to_find:                 return ir, ic 
 
 
# we create a cache for the goal position of each piece, so we don't have to 
# recalculate them every time goal_positions = {} rows_goal = string_to_list(GOAL) for number in '12345678e': 
    goal_positions[number] = find_location(rows_goal, number) 
 
 
class EigthPuzzleProblem(SearchProblem):     def actions(self, state): 
        '''Returns a list of the pieces we can move to the empty space.'''         rows = string_to_list(state) 
        row_e, col_e = find_location(rows, 'e') 
 
        actions = []         if row_e > 0: 
            actions.append(rows[row_e - 1][col_e])         if row_e < 2: 
            actions.append(rows[row_e + 1][col_e])         if col_e > 0:             actions.append(rows[row_e][col_e - 1])         if col_e < 2: 
            actions.append(rows[row_e][col_e + 1]) 
 
        return actions 
 
    def result(self, state, action): 
        '''Return the resulting state after moving a piece to the empty space. 
           (the "action" parameter contains the piece to move) 
        ''' 
        rows = string_to_list(state)         row_e, col_e = find_location(rows, 'e') 
        row_n, col_n = find_location(rows, action) 
 
        rows[row_e][col_e], rows[row_n][col_n] = rows[row_n][col_n], rows[row_e][col_e] 
 
        return list_to_string(rows) 
 
    def is_goal(self, state): 
        '''Returns true if a state is the goal state.''' 
        return state == GOAL 
 
    def cost(self, state1, action, state2): 
        '''Returns the cost of performing an action. No useful on this problem, i            but needed. 
        ''' 
        return 1 
 
    def heuristic(self, state): 
        '''Returns an *estimation* of the distance from a state to the goal.            We are using the manhattan distance. 
        ''' 
        rows = string_to_list(state)         distance = 0         for number in '12345678e':             row_n, col_n = find_location(rows, number)             row_n_goal, col_n_goal = goal_positions[number]             distance += abs(row_n - row_n_goal) + abs(col_n - col_n_goal)         return distance result = astar(EigthPuzzleProblem(INITIAL)) for action, state in result.path():     print('Move number', action) 
--------------------------------------------------------------------------------------------------------------------------
Aim:- 
Write a program to shuffle Deck of cards. 
Diagram:- 
 
 
Python Code:- 
#first let's import random procedures since we will be shuffling import random 
 
#next, let's start building list holders so we can place our cards in there: 
cardfaces = [] 
suits = ["Hearts", "Diamonds", "Clubs", "Spades"] royals = ["J", "Q", "K", "A"] deck = [] 
 
#now, let's start using loops to add our content: for i in range(2,11): 
    cardfaces.append(str(i)) #this adds numbers 2-10 and converts them to string data 
 
for j in range(4): 
    cardfaces.append(royals[j]) #this will add the royal faces to the cardbase 
  
for k in range(4):     for l in range(13):         card = (cardfaces[l] + " of " + suits[k]) 
        #this makes each card, cycling through suits, but first through faces         deck.append(card) 
        #this adds the information to the "full deck" we want to make #now let's shuffle our deck! 
random.shuffle(deck) 
 
#now let's see the cards! for m in range(52):     print(deck[m]) 
 
OR 
# Python program to shuffle a deck of card using the module random and draw 5 cards # import modules import itertools, random # make a deck of cards 
deck = list(itertools.product(range(1,14),['Spade','Heart','Diamond','Club'])) 
# shuffle the cards random.shuffle(deck) # draw five cards print("You got:") for i in range(5): 
   print(deck[i][0], "of", deck[i][1]) 
 -------------------------------------------------------------------------------------------------------------------------- 
Implementation Of Constraints Satisfactions Problem 
 
PYTHON CODE: 
from __future__ import print_function 
 
from simpleai.search import CspProblem, backtrack, min_conflicts, 
MOST_CONSTRAINED_VARIABLE, HIGHEST_DEGREE_VARIABLE, 
LEAST_CONSTRAINING_VALUE 
 
variables = ('WA', 'NT', 'SA', 'Q', 'NSW', 'V', 'T') 
 
domains = dict((v, ['red', 'green', 'blue']) for v in variables) 
 
def const_different(variables, values):     return values[0] != values[1]  # expect the value of the neighbors to be different 
 
constraints = [ 
    (('WA', 'NT'), const_different), 
    (('WA', 'SA'), const_different), 
    (('SA', 'NT'), const_different), 
    (('SA', 'Q'), const_different), 
    (('NT', 'Q'), const_different), 
    (('SA', 'NSW'), const_different), 
    (('Q', 'NSW'), const_different), 
    (('SA', 'V'), const_different), 
    (('NSW', 'V'), const_different), 
] 
 
my_problem = CspProblem(variables, domains, constraints) 
 
print(backtrack(my_problem)) 
print(backtrack(my_problem, 
variable_heuristic=MOST_CONSTRAINED_VARIABLE)) print(backtrack(my_problem, 
variable_heuristic=HIGHEST_DEGREE_VARIABLE)) print(backtrack(my_problem, 
value_heuristic=LEAST_CONSTRAINING_VALUE)) print(backtrack(my_problem, 
variable_heuristic=MOST_CONSTRAINED_VARIABLE, 
value_heuristic=LEAST_CONSTRAINING_VALUE)) print(backtrack(my_problem, 
variable_heuristic=HIGHEST_DEGREE_VARIABLE, 
value_heuristic=LEAST_CONSTRAINING_VALUE)) print(min_conflicts(my_problem)) 

 
 
 
 
 
